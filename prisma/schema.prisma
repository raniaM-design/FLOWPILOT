// Prisma schema for FlowPilot
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Models
model User {
  id                      String   @id @default(cuid())
  email                   String   @unique
  passwordHash            String
  role                    String   @default("USER") // "USER" | "ADMIN" | "SUPPORT"
  preferredLanguage       String? // "fr" | "en"
  // Préférences d'affichage
  displayReduceAnimations Boolean  @default(false)
  displayMode             String? // "standard" | "simplified"
  displayDensity          String? // "comfort" | "standard" | "compact"
  displayTheme            String? // "light" | "dark" | "system"
  createdAt               DateTime @default(now())

  projects         Project[]
  createdDecisions Decision[]
  createdActions   ActionItem[]    @relation("CreatedActions")
  assignedActions  ActionItem[]    @relation("AssignedActions")
  meetings         Meeting[]
  outlookAccount   OutlookAccount?
  outlookSyncState OutlookSyncState?
  passwordResetTokens PasswordResetToken[]
  notifications    Notification[]
  messages         Message[]
}

model Project {
  id          String   @id @default(cuid())
  ownerId     String
  owner       User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  name        String
  description String?
  client      String?  // Nom du client
  teamMembers String?  // JSON array des membres d'équipe
  status      String   @default("ACTIVE") // ProjectStatus: ACTIVE | PAUSED | DONE
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  decisions Decision[]
  actions   ActionItem[]
  meetings  Meeting[]

  @@index([ownerId])
  @@index([status])
}

model Decision {
  id          String   @id @default(cuid())
  projectId   String
  createdById String
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  createdBy   User     @relation(fields: [createdById], references: [id], onDelete: Cascade)
  title       String
  context     String?
  decision    String?
  status      String   @default("DRAFT") // DecisionStatus: DRAFT | DECIDED | ARCHIVED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  actions ActionItem[]

  @@index([projectId])
  @@index([status])
}

model ActionItem {
  id          String    @id @default(cuid())
  projectId   String
  decisionId  String?
  meetingId   String?
  createdById String
  assigneeId  String?
  title       String
  description String?
  status      String    @default("TODO") // ActionStatus: TODO | DOING | DONE | BLOCKED
  dueDate     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  project   Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  decision  Decision? @relation(fields: [decisionId], references: [id], onDelete: SetNull)
  meeting   Meeting?  @relation(fields: [meetingId], references: [id], onDelete: SetNull)
  createdBy User      @relation("CreatedActions", fields: [createdById], references: [id], onDelete: Cascade)
  assignee  User?     @relation("AssignedActions", fields: [assigneeId], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([decisionId])
  @@index([meetingId])
  @@index([assigneeId])
  @@index([status])
  @@index([dueDate])
}

model Meeting {
  id                    String    @id @default(cuid())
  ownerId               String
  owner                 User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  projectId             String? // Projet lié à la réunion (optionnel)
  project               Project?  @relation(fields: [projectId], references: [id], onDelete: SetNull)
  title                 String
  date                  DateTime
  participants          String?
  context               String? // Lien projet/client optionnel (texte libre)
  raw_notes             String // Texte du compte rendu
  analysisJson          String? // Dernier résultat d'analyse (JSON)
  analyzedAt            DateTime? // Date de dernière analyse
  externalProvider      String? // "outlook"
  externalEventId       String? // id event Outlook (unique par user)
  externalCalendarId    String?
  externalICalUId       String? // iCalUId Outlook (pour détection doublons)
  externalLastModified   DateTime? // lastModifiedDateTime Outlook
  externalIsCancelled   Boolean   @default(false) // isCancelled Outlook
  externalStartDateTime DateTime? // start.dateTime Outlook (normalisé)
  externalEndDateTime   DateTime? // end.dateTime Outlook (normalisé)
  isSynced              Boolean   @default(false)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  actions ActionItem[]

  @@unique([ownerId, externalEventId])
  @@index([ownerId])
  @@index([date])
  @@index([externalICalUId])
  @@index([projectId])
}

model OutlookAccount {
  id               String   @id @default(cuid())
  userId           String   @unique
  provider         String   @default("outlook")
  email            String?  // Email Outlook connecté (ex: user@outlook.com)
  providerAccountId String? // ID du compte Microsoft (ex: objectId Azure AD)
  accessToken      String?  // Optionnel (peut être null si seul refreshToken stocké)
  refreshToken     String   // Obligatoire
  expiresAt        DateTime
  scope            String?
  tokenType        String?
  connectedAt      DateTime @default(now()) // Date de connexion du compte Outlook
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model OutlookSyncState {
  id           String   @id @default(cuid())
  userId       String   @unique
  deltaLink    String?  // Delta link pour la prochaine sync incrémentale
  lastSyncAt   DateTime? // Date de la dernière synchronisation
  syncRangeStart DateTime? // Plage de sync (start)
  syncRangeEnd   DateTime? // Plage de sync (end)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  tokenHash String   @unique // Hash du token (jamais en clair)
  expiresAt DateTime
  createdAt DateTime @default(now())
  usedAt    DateTime? // Date d'utilisation (pour invalider après usage)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  kind      String   // action_assigned | deadline_soon | overdue | mention | comment | import_done | import_failed | export_ready | security_alert | system
  priority  String   @default("normal") // low | normal | high
  title     String
  body      String?
  targetUrl String?
  isRead    Boolean  @default(false)
  readAt    DateTime?
  dedupeKey String?  // Pour éviter les doublons (ex: "deadline:actionId:date")
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@index([dedupeKey])
  @@index([kind])
}

model Message {
  id        String   @id @default(cuid())
  userId    String
  type      String   // ai_summary | product_announcement | team_message
  subject   String
  content   String   // Markdown ou texte
  isRead    Boolean  @default(false)
  readAt    DateTime?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@index([type])
}
